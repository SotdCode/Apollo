<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>paramiko.Channel</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="paramiko-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="paramiko-module.html">Package&nbsp;paramiko</a> ::
        Class&nbsp;Channel
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="paramiko.Channel-class.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== CLASS DESCRIPTION ==================== -->
<h1 class="epydoc">Class Channel</h1><p class="nomargin-top"><span class="codelink"><a href="paramiko-pysrc.html#Channel">source&nbsp;code</a></span></p>
<pre class="base-tree">
object --+
         |
        <strong class="uidshort">Channel</strong>
</pre>

<hr />
<p>A secure tunnel across an SSH <a href="paramiko.Transport-class.html" 
  class="link">Transport</a>.  A Channel is meant to behave like a socket, 
  and has an API that should be indistinguishable from the python socket 
  API.</p>
  <p>Because SSH2 has a windowing kind of flow control, if you stop reading
  data from a Channel and its buffer fills up, the server will be unable to
  send you any more data until you read some of it.  (This won't affect 
  other channels on the same transport -- all channels on a single 
  transport are flow-controlled independently.)  Similarly, if the server 
  isn't reading data you send, calls to <a 
  href="paramiko.Channel-class.html#send" class="link">send</a> may block, 
  unless you set a timeout.  This is exactly like a normal network socket, 
  so it shouldn't be too surprising.</p>

<!-- ==================== INSTANCE METHODS ==================== -->
<a name="section-InstanceMethods"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Instance Methods</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a name="__del__"></a><span class="summary-sig-name">__del__</span>(<span class="summary-sig-arg">self</span>)</span></td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#__init__" class="summary-sig-name">__init__</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">chanid</span>)</span><br />
      Create a new channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">str</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#__repr__" class="summary-sig-name">__repr__</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Return a string representation of this object, for debugging.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#close" class="summary-sig-name">close</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Close the channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#exec_command" class="summary-sig-name">exec_command</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">command</span>)</span><br />
      Execute a command on the server.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#exit_status_ready" class="summary-sig-name">exit_status_ready</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Return true if the remote process has exited and returned an exit 
      status.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#fileno" class="summary-sig-name">fileno</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Returns an OS-level file descriptor which can be used for polling, 
      but but <i>not</i> for reading or writing.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#get_id" class="summary-sig-name">get_id</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Return the ID # for this channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">str</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#get_name" class="summary-sig-name">get_name</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Get the name of this channel that was previously set by <a 
      href="paramiko.Channel-class.html#set_name" 
      class="link">set_name</a>.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#get_pty" class="summary-sig-name">get_pty</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">term</span>=<span class="summary-sig-default"><code class="variable-quote">'</code><code class="variable-string">vt100</code><code class="variable-quote">'</code></span>,
        <span class="summary-sig-arg">width</span>=<span class="summary-sig-default">80</span>,
        <span class="summary-sig-arg">height</span>=<span class="summary-sig-default">24</span>)</span><br />
      Request a pseudo-terminal from the server.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type"><a href="paramiko.Transport-class.html" class="link">Transport</a></span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#get_transport" class="summary-sig-name">get_transport</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Return the <a href="paramiko.Transport-class.html" 
      class="link">Transport</a> associated with this channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">tuple(str, int)</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#getpeername" class="summary-sig-name">getpeername</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Return the address of the remote side of this Channel, if possible.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">float</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#gettimeout" class="summary-sig-name">gettimeout</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Returns the timeout in seconds (as a float) associated with socket 
      operations, or <code>None</code> if no timeout is set.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#invoke_shell" class="summary-sig-name">invoke_shell</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Request an interactive shell session on this channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#invoke_subsystem" class="summary-sig-name">invoke_subsystem</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">subsystem</span>)</span><br />
      Request a subsystem on the server (for example, <code>sftp</code>).</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">ChannelFile</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#makefile" class="summary-sig-name">makefile</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">*params</span>)</span><br />
      Return a file-like object associated with this channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">ChannelFile</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#makefile_stderr" class="summary-sig-name">makefile_stderr</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">*params</span>)</span><br />
      Return a file-like object associated with this channel's stderr 
      stream.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">str</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#recv" class="summary-sig-name">recv</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">nbytes</span>)</span><br />
      Receive data from the channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#recv_exit_status" class="summary-sig-name">recv_exit_status</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Return the exit status from the process on the server.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">boolean</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#recv_ready" class="summary-sig-name">recv_ready</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Returns true if data is buffered and ready to be read from this 
      channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">str</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#recv_stderr" class="summary-sig-name">recv_stderr</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">nbytes</span>)</span><br />
      Receive data from the channel's stderr stream.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">boolean</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#recv_stderr_ready" class="summary-sig-name">recv_stderr_ready</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Returns true if data is buffered and ready to be read from this 
      channel's stderr stream.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#request_x11" class="summary-sig-name">request_x11</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">screen_number</span>=<span class="summary-sig-default">0</span>,
        <span class="summary-sig-arg">auth_protocol</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">auth_cookie</span>=<span class="summary-sig-default">None</span>,
        <span class="summary-sig-arg">single_connection</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">handler</span>=<span class="summary-sig-default">None</span>)</span><br />
      Request an x11 session on this channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#resize_pty" class="summary-sig-name">resize_pty</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">width</span>=<span class="summary-sig-default">80</span>,
        <span class="summary-sig-arg">height</span>=<span class="summary-sig-default">24</span>)</span><br />
      Resize the pseudo-terminal.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#send" class="summary-sig-name">send</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">s</span>)</span><br />
      Send data to the channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#send_exit_status" class="summary-sig-name">send_exit_status</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">status</span>)</span><br />
      Send the exit status of an executed command to the client.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">boolean</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#send_ready" class="summary-sig-name">send_ready</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Returns true if data can be written to this channel without blocking.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#send_stderr" class="summary-sig-name">send_stderr</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">s</span>)</span><br />
      Send data to the channel on the &quot;stderr&quot; stream.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#sendall" class="summary-sig-name">sendall</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">s</span>)</span><br />
      Send data to the channel, without allowing partial results.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#sendall_stderr" class="summary-sig-name">sendall_stderr</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">s</span>)</span><br />
      Send data to the channel's &quot;stderr&quot; stream, without 
      allowing partial results.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#set_combine_stderr" class="summary-sig-name">set_combine_stderr</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">combine</span>)</span><br />
      Set whether stderr should be combined into stdout on this channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#set_name" class="summary-sig-name">set_name</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">name</span>)</span><br />
      Set a name for this channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#setblocking" class="summary-sig-name">setblocking</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">blocking</span>)</span><br />
      Set blocking or non-blocking mode of the channel: if 
      <code>blocking</code> is 0, the channel is set to non-blocking mode; 
      otherwise it's set to blocking mode.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#settimeout" class="summary-sig-name">settimeout</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">timeout</span>)</span><br />
      Set a timeout on blocking read/write operations.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#shutdown" class="summary-sig-name">shutdown</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">how</span>)</span><br />
      Shut down one or both halves of the connection.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#shutdown_read" class="summary-sig-name">shutdown_read</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Shutdown the receiving side of this socket, closing the stream in the
      incoming direction.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.Channel-class.html#shutdown_write" class="summary-sig-name">shutdown_write</a>(<span class="summary-sig-arg">self</span>)</span><br />
      Shutdown the sending side of this socket, closing the stream in the 
      outgoing direction.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__delattr__</code>,
      <code>__format__</code>,
      <code>__getattribute__</code>,
      <code>__hash__</code>,
      <code>__new__</code>,
      <code>__reduce__</code>,
      <code>__reduce_ex__</code>,
      <code>__setattr__</code>,
      <code>__sizeof__</code>,
      <code>__str__</code>,
      <code>__subclasshook__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== PROPERTIES ==================== -->
<a name="section-Properties"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Properties</span></td>
</tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__class__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== METHOD DETAILS ==================== -->
<a name="section-MethodDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Method Details</span></td>
</tr>
</table>
<a name="__init__"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">__init__</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">chanid</span>)</span>
    <br /><em class="fname">(Constructor)</em>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Create a new channel.  The channel is not associated with any 
  particular session or <a href="paramiko.Transport-class.html" 
  class="link">Transport</a> until the Transport attaches it. Normally you 
  would only call this method from the constructor of a subclass of <a 
  href="paramiko.Channel-class.html" class="link">Channel</a>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>chanid</code></strong> (int) - the ID of this channel, as passed by an existing <a 
          href="paramiko.Transport-class.html" class="link">Transport</a>.</li>
    </ul></dd>
    <dt>Overrides:
        object.__init__
    </dt>
  </dl>
</td></tr></table>
</div>
<a name="__repr__"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">__repr__</span>(<span class="sig-arg">self</span>)</span>
    <br /><em class="fname">(Representation operator)</em>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return a string representation of this object, for debugging.</p>
  <dl class="fields">
    <dt>Returns: str</dt>
    <dt>Overrides:
        object.__repr__
    </dt>
  </dl>
</td></tr></table>
</div>
<a name="close"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">close</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Close the channel.  All future read/write operations on the channel 
  will fail.  The remote end will receive no more data (after queued data 
  is flushed).  Channels are automatically closed when their <a 
  href="paramiko.Transport-class.html" class="link">Transport</a> is closed
  or when they are garbage collected.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<a name="exec_command"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">exec_command</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">command</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Execute a command on the server.  If the server allows it, the channel
  will then be directly connected to the stdin, stdout, and stderr of the 
  command being executed.</p>
  <p>When the command finishes executing, the channel will be closed and 
  can't be reused.  You must open a new channel if you wish to execute 
  another command.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>command</code></strong> (str) - a shell command to execute.</li>
    </ul></dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'><a href="paramiko.SSHException-class.html">SSHException</a></strong></code> - if the request was rejected or the channel was closed</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="exit_status_ready"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">exit_status_ready</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return true if the remote process has exited and returned an exit 
  status. You may use this to poll the process status if you don't want to 
  block in <a href="paramiko.Channel-class.html#recv_exit_status" 
  class="link">recv_exit_status</a>. Note that the server may not return an
  exit status in some cases (like bad servers).</p>
  <dl class="fields">
    <dt>Returns: bool</dt>
        <dd>True if <a href="paramiko.Channel-class.html#recv_exit_status" 
          class="link">recv_exit_status</a> will return immediately</dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.7.3
      </p>
</div></td></tr></table>
</div>
<a name="fileno"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">fileno</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns an OS-level file descriptor which can be used for polling, but
  but <i>not</i> for reading or writing.  This is primaily to allow 
  python's <code>select</code> module to work.</p>
  <p>The first time <code>fileno</code> is called on a channel, a pipe is 
  created to simulate real OS-level file descriptor (FD) behavior.  Because
  of this, two OS-level FDs are created, which will use up FDs faster than 
  normal. (You won't notice this effect unless you have hundreds of 
  channels open at the same time.)</p>
  <dl class="fields">
    <dt>Returns: int</dt>
        <dd>an OS-level file descriptor</dd>
  </dl>
<div class="fields">      <p><strong>Warning:</strong>
        This method causes channel reads to be slightly less efficient.
      </p>
</div></td></tr></table>
</div>
<a name="get_id"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_id</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return the ID # for this channel.  The channel ID is unique across a 
  <a href="paramiko.Transport-class.html" class="link">Transport</a> and 
  usually a small number.  It's also the number passed to <a 
  href="paramiko.ServerInterface-class.html#check_channel_request" 
  class="link">ServerInterface.check_channel_request</a> when determining 
  whether to accept a channel request in server mode.</p>
  <dl class="fields">
    <dt>Returns: int</dt>
        <dd>the ID of this channel.</dd>
  </dl>
</td></tr></table>
</div>
<a name="get_name"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_name</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Get the name of this channel that was previously set by <a 
  href="paramiko.Channel-class.html#set_name" 
  class="link">set_name</a>.</p>
  <dl class="fields">
    <dt>Returns: str</dt>
        <dd>the name of this channel.</dd>
  </dl>
</td></tr></table>
</div>
<a name="get_pty"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_pty</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">term</span>=<span class="sig-default"><code class="variable-quote">'</code><code class="variable-string">vt100</code><code class="variable-quote">'</code></span>,
        <span class="sig-arg">width</span>=<span class="sig-default">80</span>,
        <span class="sig-arg">height</span>=<span class="sig-default">24</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Request a pseudo-terminal from the server.  This is usually used right
  after creating a client channel, to ask the server to provide some basic 
  terminal semantics for a shell invoked with <a 
  href="paramiko.Channel-class.html#invoke_shell" 
  class="link">invoke_shell</a>. It isn't necessary (or desirable) to call 
  this method if you're going to exectue a single command with <a 
  href="paramiko.Channel-class.html#exec_command" 
  class="link">exec_command</a>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>term</code></strong> (str) - the terminal type to emulate (for example, <code>'vt100'</code>)</li>
        <li><strong class="pname"><code>width</code></strong> (int) - width (in characters) of the terminal screen</li>
        <li><strong class="pname"><code>height</code></strong> (int) - height (in characters) of the terminal screen</li>
    </ul></dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'><a href="paramiko.SSHException-class.html">SSHException</a></strong></code> - if the request was rejected or the channel was closed</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="get_transport"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_transport</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return the <a href="paramiko.Transport-class.html" 
  class="link">Transport</a> associated with this channel.</p>
  <dl class="fields">
    <dt>Returns: <a href="paramiko.Transport-class.html" class="link">Transport</a></dt>
        <dd>the <a href="paramiko.Transport-class.html" 
          class="link">Transport</a> that was used to create this channel.</dd>
  </dl>
</td></tr></table>
</div>
<a name="getpeername"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">getpeername</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return the address of the remote side of this Channel, if possible. 
  This is just a wrapper around <code>'getpeername'</code> on the 
  Transport, used to provide enough of a socket-like interface to allow 
  asyncore to work. (asyncore likes to call 
  <code>'getpeername'</code>.)</p>
  <dl class="fields">
    <dt>Returns: tuple(str, int)</dt>
        <dd>the address if the remote host, if known</dd>
  </dl>
</td></tr></table>
</div>
<a name="gettimeout"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">gettimeout</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns the timeout in seconds (as a float) associated with socket 
  operations, or <code>None</code> if no timeout is set.  This reflects the
  last call to <a href="paramiko.Channel-class.html#setblocking" 
  class="link">setblocking</a> or <a 
  href="paramiko.Channel-class.html#settimeout" 
  class="link">settimeout</a>.</p>
  <dl class="fields">
    <dt>Returns: float</dt>
        <dd>timeout in seconds, or <code>None</code>.</dd>
  </dl>
</td></tr></table>
</div>
<a name="invoke_shell"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">invoke_shell</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Request an interactive shell session on this channel.  If the server 
  allows it, the channel will then be directly connected to the stdin, 
  stdout, and stderr of the shell.</p>
  <p>Normally you would call <a href="paramiko.Channel-class.html#get_pty" 
  class="link">get_pty</a> before this, in which case the shell will 
  operate through the pty, and the channel will be connected to the stdin 
  and stdout of the pty.</p>
  <p>When the shell exits, the channel will be closed and can't be reused. 
  You must open a new channel if you wish to open another shell.</p>
  <dl class="fields">
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'><a href="paramiko.SSHException-class.html">SSHException</a></strong></code> - if the request was rejected or the channel was closed</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="invoke_subsystem"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">invoke_subsystem</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">subsystem</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Request a subsystem on the server (for example, <code>sftp</code>).  
  If the server allows it, the channel will then be directly connected to 
  the requested subsystem.</p>
  <p>When the subsystem finishes, the channel will be closed and can't be 
  reused.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>subsystem</code></strong> (str) - name of the subsystem being requested.</li>
    </ul></dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'><a href="paramiko.SSHException-class.html">SSHException</a></strong></code> - if the request was rejected or the channel was closed</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="makefile"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">makefile</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">*params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return a file-like object associated with this channel.  The optional 
  <code>mode</code> and <code>bufsize</code> arguments are interpreted the 
  same way as by the built-in <code>file()</code> function in python.</p>
  <dl class="fields">
    <dt>Returns: ChannelFile</dt>
        <dd>object which can be used for python file I/O.</dd>
  </dl>
</td></tr></table>
</div>
<a name="makefile_stderr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">makefile_stderr</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">*params</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return a file-like object associated with this channel's stderr 
  stream.   Only channels using <a 
  href="paramiko.Channel-class.html#exec_command" 
  class="link">exec_command</a> or <a 
  href="paramiko.Channel-class.html#invoke_shell" 
  class="link">invoke_shell</a> without a pty will ever have data on the 
  stderr stream.</p>
  <p>The optional <code>mode</code> and <code>bufsize</code> arguments are 
  interpreted the same way as by the built-in <code>file()</code> function 
  in python.  For a client, it only makes sense to open this file for 
  reading.  For a server, it only makes sense to open this file for 
  writing.</p>
  <dl class="fields">
    <dt>Returns: ChannelFile</dt>
        <dd>object which can be used for python file I/O.</dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.1
      </p>
</div></td></tr></table>
</div>
<a name="recv"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">recv</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">nbytes</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Receive data from the channel.  The return value is a string 
  representing the data received.  The maximum amount of data to be 
  received at once is specified by <code>nbytes</code>.  If a string of 
  length zero is returned, the channel stream has closed.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>nbytes</code></strong> (int) - maximum number of bytes to read.</li>
    </ul></dd>
    <dt>Returns: str</dt>
        <dd>data.</dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'>socket.timeout</strong></code> - if no data is ready before the timeout set by <a 
        href="paramiko.Channel-class.html#settimeout" 
        class="link">settimeout</a>.</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="recv_exit_status"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">recv_exit_status</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return the exit status from the process on the server.  This is mostly
  useful for retrieving the reults of an <a 
  href="paramiko.Channel-class.html#exec_command" 
  class="link">exec_command</a>. If the command hasn't finished yet, this 
  method will wait until it does, or until the channel is closed.  If no 
  exit status is provided by the server, -1 is returned.</p>
  <dl class="fields">
    <dt>Returns: int</dt>
        <dd>the exit code of the process on the server.</dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.2
      </p>
</div></td></tr></table>
</div>
<a name="recv_ready"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">recv_ready</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns true if data is buffered and ready to be read from this 
  channel.  A <code>False</code> result does not mean that the channel has 
  closed; it means you may need to wait before more data arrives.</p>
  <dl class="fields">
    <dt>Returns: boolean</dt>
        <dd><code>True</code> if a <a href="paramiko.Channel-class.html#recv"
          class="link">recv</a> call on this channel would immediately 
          return at least one byte; <code>False</code> otherwise.</dd>
  </dl>
</td></tr></table>
</div>
<a name="recv_stderr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">recv_stderr</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">nbytes</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Receive data from the channel's stderr stream.  Only channels using <a
  href="paramiko.Channel-class.html#exec_command" 
  class="link">exec_command</a> or <a 
  href="paramiko.Channel-class.html#invoke_shell" 
  class="link">invoke_shell</a> without a pty will ever have data on the 
  stderr stream.  The return value is a string representing the data 
  received.  The maximum amount of data to be received at once is specified
  by <code>nbytes</code>.  If a string of length zero is returned, the 
  channel stream has closed.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>nbytes</code></strong> (int) - maximum number of bytes to read.</li>
    </ul></dd>
    <dt>Returns: str</dt>
        <dd>data.</dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'>socket.timeout</strong></code> - if no data is ready before the timeout set by <a 
        href="paramiko.Channel-class.html#settimeout" 
        class="link">settimeout</a>.</li>
    </ul></dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.1
      </p>
</div></td></tr></table>
</div>
<a name="recv_stderr_ready"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">recv_stderr_ready</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns true if data is buffered and ready to be read from this 
  channel's stderr stream.  Only channels using <a 
  href="paramiko.Channel-class.html#exec_command" 
  class="link">exec_command</a> or <a 
  href="paramiko.Channel-class.html#invoke_shell" 
  class="link">invoke_shell</a> without a pty will ever have data on the 
  stderr stream.</p>
  <dl class="fields">
    <dt>Returns: boolean</dt>
        <dd><code>True</code> if a <a 
          href="paramiko.Channel-class.html#recv_stderr" 
          class="link">recv_stderr</a> call on this channel would 
          immediately return at least one byte; <code>False</code> 
          otherwise.</dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.1
      </p>
</div></td></tr></table>
</div>
<a name="request_x11"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">request_x11</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">screen_number</span>=<span class="sig-default">0</span>,
        <span class="sig-arg">auth_protocol</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">auth_cookie</span>=<span class="sig-default">None</span>,
        <span class="sig-arg">single_connection</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">handler</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Request an x11 session on this channel.  If the server allows it, 
  further x11 requests can be made from the server to the client, when an 
  x11 application is run in a shell session.</p>
  <p>From RFC4254:</p>
<pre class="literalblock">
   It is RECOMMENDED that the 'x11 authentication cookie' that is
   sent be a fake, random cookie, and that the cookie be checked and
   replaced by the real cookie when a connection request is received.
</pre>
  <p>If you omit the auth_cookie, a new secure random 128-bit value will be
  generated, used, and returned.  You will need to use this value to verify
  incoming x11 requests and replace them with the actual local x11 cookie 
  (which requires some knoweldge of the x11 protocol).</p>
  <p>If a handler is passed in, the handler is called from another thread 
  whenever a new x11 connection arrives.  The default handler queues up 
  incoming x11 connections, which may be retrieved using <a 
  href="paramiko.Transport-class.html#accept" 
  class="link">Transport.accept</a>.  The handler's calling signature 
  is:</p>
<pre class="literalblock">
   handler(channel: Channel, (address: str, port: int))
</pre>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>screen_number</code></strong> (int) - the x11 screen number (0, 10, etc)</li>
        <li><strong class="pname"><code>auth_protocol</code></strong> (str) - the name of the X11 authentication method used; if none is given,
          <code>&quot;MIT-MAGIC-COOKIE-1&quot;</code> is used</li>
        <li><strong class="pname"><code>auth_cookie</code></strong> (str) - hexadecimal string containing the x11 auth cookie; if none is 
          given, a secure random 128-bit value is generated</li>
        <li><strong class="pname"><code>single_connection</code></strong> (bool) - if True, only a single x11 connection will be forwarded (by 
          default, any number of x11 connections can arrive over this 
          session)</li>
        <li><strong class="pname"><code>handler</code></strong> (function) - an optional handler to use for incoming X11 connections</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>the auth_cookie used</dd>
  </dl>
</td></tr></table>
</div>
<a name="resize_pty"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">resize_pty</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">width</span>=<span class="sig-default">80</span>,
        <span class="sig-arg">height</span>=<span class="sig-default">24</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Resize the pseudo-terminal.  This can be used to change the width and 
  height of the terminal emulation created in a previous <a 
  href="paramiko.Channel-class.html#get_pty" class="link">get_pty</a> 
  call.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>width</code></strong> (int) - new width (in characters) of the terminal screen</li>
        <li><strong class="pname"><code>height</code></strong> (int) - new height (in characters) of the terminal screen</li>
    </ul></dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'><a href="paramiko.SSHException-class.html">SSHException</a></strong></code> - if the request was rejected or the channel was closed</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="send"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">send</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">s</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Send data to the channel.  Returns the number of bytes sent, or 0 if 
  the channel stream is closed.  Applications are responsible for checking 
  that all data has been sent: if only some of the data was transmitted, 
  the application needs to attempt delivery of the remaining data.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>s</code></strong> (str) - data to send</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>number of bytes actually sent</dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'>socket.timeout</strong></code> - if no data could be sent before the timeout set by <a 
        href="paramiko.Channel-class.html#settimeout" 
        class="link">settimeout</a>.</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="send_exit_status"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">send_exit_status</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">status</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Send the exit status of an executed command to the client.  (This 
  really only makes sense in server mode.)  Many clients expect to get some
  sort of status code back from an executed command after it completes.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>status</code></strong> (int) - the exit code of the process</li>
    </ul></dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.2
      </p>
</div></td></tr></table>
</div>
<a name="send_ready"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">send_ready</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Returns true if data can be written to this channel without blocking. 
  This means the channel is either closed (so any write attempt would 
  return immediately) or there is at least one byte of space in the 
  outbound buffer. If there is at least one byte of space in the outbound 
  buffer, a <a href="paramiko.Channel-class.html#send" 
  class="link">send</a> call will succeed immediately and return the number
  of bytes actually written.</p>
  <dl class="fields">
    <dt>Returns: boolean</dt>
        <dd><code>True</code> if a <a href="paramiko.Channel-class.html#send"
          class="link">send</a> call on this channel would immediately 
          succeed or fail</dd>
  </dl>
</td></tr></table>
</div>
<a name="send_stderr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">send_stderr</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">s</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Send data to the channel on the &quot;stderr&quot; stream.  This is 
  normally only used by servers to send output from shell commands -- 
  clients won't use this.  Returns the number of bytes sent, or 0 if the 
  channel stream is closed.  Applications are responsible for checking that
  all data has been sent: if only some of the data was transmitted, the 
  application needs to attempt delivery of the remaining data.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>s</code></strong> (str) - data to send.</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>number of bytes actually sent.</dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'>socket.timeout</strong></code> - if no data could be sent before the timeout set by <a 
        href="paramiko.Channel-class.html#settimeout" 
        class="link">settimeout</a>.</li>
    </ul></dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.1
      </p>
</div></td></tr></table>
</div>
<a name="sendall"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sendall</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">s</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Send data to the channel, without allowing partial results.  Unlike <a
  href="paramiko.Channel-class.html#send" class="link">send</a>, this 
  method continues to send data from the given string until either all data
  has been sent or an error occurs.  Nothing is returned.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>s</code></strong> (str) - data to send.</li>
    </ul></dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'>socket.timeout</strong></code> - if sending stalled for longer than the timeout set by <a 
        href="paramiko.Channel-class.html#settimeout" 
        class="link">settimeout</a>.</li>
        <li><code><strong class='fraise'>socket.error</strong></code> - if an error occured before the entire string was sent.</li>
    </ul></dd>
  </dl>
<div class="fields">      <p><strong>Note:</strong>
        If the channel is closed while only part of the data hase been 
        sent, there is no way to determine how much data (if any) was sent.
        This is irritating, but identically follows python's API.
      </p>
</div></td></tr></table>
</div>
<a name="sendall_stderr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">sendall_stderr</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">s</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Send data to the channel's &quot;stderr&quot; stream, without allowing
  partial results.  Unlike <a 
  href="paramiko.Channel-class.html#send_stderr" 
  class="link">send_stderr</a>, this method continues to send data from the
  given string until all data has been sent or an error occurs. Nothing is 
  returned.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>s</code></strong> (str) - data to send to the client as &quot;stderr&quot; output.</li>
    </ul></dd>
    <dt>Raises:</dt>
    <dd><ul class="nomargin-top">
        <li><code><strong class='fraise'>socket.timeout</strong></code> - if sending stalled for longer than the timeout set by <a 
        href="paramiko.Channel-class.html#settimeout" 
        class="link">settimeout</a>.</li>
        <li><code><strong class='fraise'>socket.error</strong></code> - if an error occured before the entire string was sent.</li>
    </ul></dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.1
      </p>
</div></td></tr></table>
</div>
<a name="set_combine_stderr"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_combine_stderr</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">combine</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Set whether stderr should be combined into stdout on this channel. The
  default is <code>False</code>, but in some cases it may be convenient to 
  have both streams combined.</p>
  <p>If this is <code>False</code>, and <a 
  href="paramiko.Channel-class.html#exec_command" 
  class="link">exec_command</a> is called (or <code>invoke_shell</code> 
  with no pty), output to stderr will not show up through the <a 
  href="paramiko.Channel-class.html#recv" class="link">recv</a> and <a 
  href="paramiko.Channel-class.html#recv_ready" class="link">recv_ready</a>
  calls.  You will have to use <a 
  href="paramiko.Channel-class.html#recv_stderr" 
  class="link">recv_stderr</a> and <a 
  href="paramiko.Channel-class.html#recv_stderr_ready" 
  class="link">recv_stderr_ready</a> to get stderr output.</p>
  <p>If this is <code>True</code>, data will never show up via <a 
  href="paramiko.Channel-class.html#recv_stderr" 
  class="link">recv_stderr</a> or <a 
  href="paramiko.Channel-class.html#recv_stderr_ready" 
  class="link">recv_stderr_ready</a>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>combine</code></strong> (bool) - <code>True</code> if stderr output should be combined into stdout
          on this channel.</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd>previous setting.</dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.1
      </p>
</div></td></tr></table>
</div>
<a name="set_name"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">set_name</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">name</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Set a name for this channel.  Currently it's only used to set the name
  of the channel in logfile entries.  The name can be fetched with the <a 
  href="paramiko.Channel-class.html#get_name" class="link">get_name</a> 
  method.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>name</code></strong> (str) - new channel name</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="setblocking"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">setblocking</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">blocking</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Set blocking or non-blocking mode of the channel: if 
  <code>blocking</code> is 0, the channel is set to non-blocking mode; 
  otherwise it's set to blocking mode. Initially all channels are in 
  blocking mode.</p>
  <p>In non-blocking mode, if a <a href="paramiko.Channel-class.html#recv" 
  class="link">recv</a> call doesn't find any data, or if a <a 
  href="paramiko.Channel-class.html#send" class="link">send</a> call can't 
  immediately dispose of the data, an error exception is raised. In 
  blocking mode, the calls block until they can proceed. An EOF condition 
  is considered &quot;immediate data&quot; for <a 
  href="paramiko.Channel-class.html#recv" class="link">recv</a>, so if the 
  channel is closed in the read direction, it will never block.</p>
  <p><code>chan.setblocking(0)</code> is equivalent to 
  <code>chan.settimeout(0)</code>; <code>chan.setblocking(1)</code> is 
  equivalent to <code>chan.settimeout(None)</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>blocking</code></strong> (int) - 0 to set non-blocking mode; non-0 to set blocking mode.</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="settimeout"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">settimeout</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">timeout</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Set a timeout on blocking read/write operations.  The 
  <code>timeout</code> argument can be a nonnegative float expressing 
  seconds, or <code>None</code>.  If a float is given, subsequent channel 
  read/write operations will raise a timeout exception if the timeout 
  period value has elapsed before the operation has completed.  Setting a 
  timeout of <code>None</code> disables timeouts on socket operations.</p>
  <p><code>chan.settimeout(0.0)</code> is equivalent to 
  <code>chan.setblocking(0)</code>; <code>chan.settimeout(None)</code> is 
  equivalent to <code>chan.setblocking(1)</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>timeout</code></strong> (float) - seconds to wait for a pending read/write operation before raising
          <code>socket.timeout</code>, or <code>None</code> for no timeout.</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="shutdown"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">shutdown</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">how</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Shut down one or both halves of the connection.  If <code>how</code> 
  is 0, further receives are disallowed.  If <code>how</code> is 1, further
  sends are disallowed.  If <code>how</code> is 2, further sends and 
  receives are disallowed.  This closes the stream in one or both 
  directions.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>how</code></strong> (int) - 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and 
          sending).</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="shutdown_read"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">shutdown_read</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Shutdown the receiving side of this socket, closing the stream in the 
  incoming direction.  After this call, future reads on this channel will 
  fail instantly.  This is a convenience method, equivalent to 
  <code>shutdown(0)</code>, for people who don't make it a habit to 
  memorize unix constants from the 1970s.</p>
  <dl class="fields">
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.2
      </p>
</div></td></tr></table>
</div>
<a name="shutdown_write"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">shutdown_write</span>(<span class="sig-arg">self</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.channel-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Shutdown the sending side of this socket, closing the stream in the 
  outgoing direction.  After this call, future writes on this channel will 
  fail instantly.  This is a convenience method, equivalent to 
  <code>shutdown(1)</code>, for people who don't make it a habit to 
  memorize unix constants from the 1970s.</p>
  <dl class="fields">
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.2
      </p>
</div></td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="paramiko-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Mon May 23 13:50:03 2011
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
