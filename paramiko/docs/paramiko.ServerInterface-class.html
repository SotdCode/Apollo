<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>paramiko.ServerInterface</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="paramiko-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="paramiko-module.html">Package&nbsp;paramiko</a> ::
        Class&nbsp;ServerInterface
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="paramiko.ServerInterface-class.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== CLASS DESCRIPTION ==================== -->
<h1 class="epydoc">Class ServerInterface</h1><p class="nomargin-top"><span class="codelink"><a href="paramiko-pysrc.html#ServerInterface">source&nbsp;code</a></span></p>
<pre class="base-tree">
object --+
         |
        <strong class="uidshort">ServerInterface</strong>
</pre>

<hr />
<p>This class defines an interface for controlling the behavior of 
  paramiko in server mode.</p>
  <p>Methods on this class are called from paramiko's primary thread, so 
  you shouldn't do too much work in them.  (Certainly nothing that blocks 
  or sleeps.)</p>

<!-- ==================== INSTANCE METHODS ==================== -->
<a name="section-InstanceMethods"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Instance Methods</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#cancel_port_forward_request" class="summary-sig-name">cancel_port_forward_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">address</span>,
        <span class="summary-sig-arg">port</span>)</span><br />
      The client would like to cancel a previous port-forwarding request.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int or InteractiveQuery</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_auth_interactive" class="summary-sig-name">check_auth_interactive</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">username</span>,
        <span class="summary-sig-arg">submethods</span>)</span><br />
      Begin an interactive authentication challenge, if supported.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int or InteractiveQuery</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_auth_interactive_response" class="summary-sig-name">check_auth_interactive_response</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">responses</span>)</span><br />
      Continue or finish an interactive authentication challenge, if 
      supported.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_auth_none" class="summary-sig-name">check_auth_none</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">username</span>)</span><br />
      Determine if a client may open channels with no (further) 
      authentication.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_auth_password" class="summary-sig-name">check_auth_password</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">username</span>,
        <span class="summary-sig-arg">password</span>)</span><br />
      Determine if a given username and password supplied by the client is 
      acceptable for use in authentication.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_auth_publickey" class="summary-sig-name">check_auth_publickey</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">username</span>,
        <span class="summary-sig-arg">key</span>)</span><br />
      Determine if a given key supplied by the client is acceptable for use
      in authentication.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_direct_tcpip_request" class="summary-sig-name">check_channel_direct_tcpip_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">chanid</span>,
        <span class="summary-sig-arg">origin</span>,
        <span class="summary-sig-arg">destination</span>)</span><br />
      Determine if a local port forwarding channel will be granted, and 
      return <code>OPEN_SUCCEEDED</code> or an error code.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_exec_request" class="summary-sig-name">check_channel_exec_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">channel</span>,
        <span class="summary-sig-arg">command</span>)</span><br />
      Determine if a shell command will be executed for the client.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_pty_request" class="summary-sig-name">check_channel_pty_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">channel</span>,
        <span class="summary-sig-arg">term</span>,
        <span class="summary-sig-arg">width</span>,
        <span class="summary-sig-arg">height</span>,
        <span class="summary-sig-arg">pixelwidth</span>,
        <span class="summary-sig-arg">pixelheight</span>,
        <span class="summary-sig-arg">modes</span>)</span><br />
      Determine if a pseudo-terminal of the given dimensions (usually 
      requested for shell access) can be provided on the given channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_request" class="summary-sig-name">check_channel_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">kind</span>,
        <span class="summary-sig-arg">chanid</span>)</span><br />
      Determine if a channel request of a given type will be granted, and 
      return <code>OPEN_SUCCEEDED</code> or an error code.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_shell_request" class="summary-sig-name">check_channel_shell_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">channel</span>)</span><br />
      Determine if a shell will be provided to the client on the given 
      channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_subsystem_request" class="summary-sig-name">check_channel_subsystem_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">channel</span>,
        <span class="summary-sig-arg">name</span>)</span><br />
      Determine if a requested subsystem will be provided to the client on 
      the given channel.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_window_change_request" class="summary-sig-name">check_channel_window_change_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">channel</span>,
        <span class="summary-sig-arg">width</span>,
        <span class="summary-sig-arg">height</span>,
        <span class="summary-sig-arg">pixelwidth</span>,
        <span class="summary-sig-arg">pixelheight</span>)</span><br />
      Determine if the pseudo-terminal on the given channel can be resized.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_channel_x11_request" class="summary-sig-name">check_channel_x11_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">channel</span>,
        <span class="summary-sig-arg">single_connection</span>,
        <span class="summary-sig-arg">auth_protocol</span>,
        <span class="summary-sig-arg">auth_cookie</span>,
        <span class="summary-sig-arg">screen_number</span>)</span><br />
      Determine if the client will be provided with an X11 session.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">bool</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_global_request" class="summary-sig-name">check_global_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">kind</span>,
        <span class="summary-sig-arg">msg</span>)</span><br />
      Handle a global request of the given <code>kind</code>.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">int</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#check_port_forward_request" class="summary-sig-name">check_port_forward_request</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">address</span>,
        <span class="summary-sig-arg">port</span>)</span><br />
      Handle a request for port forwarding.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">str</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="paramiko.ServerInterface-class.html#get_allowed_auths" class="summary-sig-name">get_allowed_auths</a>(<span class="summary-sig-arg">self</span>,
        <span class="summary-sig-arg">username</span>)</span><br />
      Return a list of authentication methods supported by the server.</td>
          <td align="right" valign="top">
            <span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__delattr__</code>,
      <code>__format__</code>,
      <code>__getattribute__</code>,
      <code>__hash__</code>,
      <code>__init__</code>,
      <code>__new__</code>,
      <code>__reduce__</code>,
      <code>__reduce_ex__</code>,
      <code>__repr__</code>,
      <code>__setattr__</code>,
      <code>__sizeof__</code>,
      <code>__str__</code>,
      <code>__subclasshook__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== PROPERTIES ==================== -->
<a name="section-Properties"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Properties</span></td>
</tr>
  <tr>
    <td colspan="2" class="summary">
    <p class="indent-wrapped-lines"><b>Inherited from <code>object</code></b>:
      <code>__class__</code>
      </p>
    </td>
  </tr>
</table>
<!-- ==================== METHOD DETAILS ==================== -->
<a name="section-MethodDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Method Details</span></td>
</tr>
</table>
<a name="cancel_port_forward_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">cancel_port_forward_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">address</span>,
        <span class="sig-arg">port</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>The client would like to cancel a previous port-forwarding request. If
  the given address and port is being forwarded across this ssh connection,
  the port should be closed.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>address</code></strong> (str) - the forwarded address</li>
        <li><strong class="pname"><code>port</code></strong> (int) - the forwarded port</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="check_auth_interactive"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_auth_interactive</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">username</span>,
        <span class="sig-arg">submethods</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Begin an interactive authentication challenge, if supported.  You 
  should override this method in server mode if you want to support the 
  <code>&quot;keyboard-interactive&quot;</code> auth type, which requires 
  you to send a series of questions for the client to answer.</p>
  <p>Return AUTH_FAILED if this auth method isn't supported.  Otherwise, 
  you should return an InteractiveQuery object containing the prompts and 
  instructions for the user.  The response will be sent via a call to <a 
  href="paramiko.ServerInterface-class.html#check_auth_interactive_response"
  class="link">check_auth_interactive_response</a>.</p>
  <p>The default implementation always returns AUTH_FAILED.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>username</code></strong> (str) - the username of the authenticating client</li>
        <li><strong class="pname"><code>submethods</code></strong> (str) - a comma-separated list of methods preferred by the client 
          (usually empty)</li>
    </ul></dd>
    <dt>Returns: int or InteractiveQuery</dt>
        <dd>AUTH_FAILED if this auth method isn't supported; otherwise an 
          object containing queries for the user</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_auth_interactive_response"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_auth_interactive_response</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">responses</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Continue or finish an interactive authentication challenge, if 
  supported.  You should override this method in server mode if you want to
  support the <code>&quot;keyboard-interactive&quot;</code> auth type.</p>
  <p>Return AUTH_FAILED if the responses are not accepted, AUTH_SUCCESSFUL 
  if the responses are accepted and complete the authentication, or 
  AUTH_PARTIALLY_SUCCESSFUL if your authentication is stateful, and this 
  set of responses is accepted for authentication, but more authentication 
  is required.  (In this latter case, <a 
  href="paramiko.ServerInterface-class.html#get_allowed_auths" 
  class="link">get_allowed_auths</a> will be called to report to the client
  what options it has for continuing the authentication.)</p>
  <p>If you wish to continue interactive authentication with more 
  questions, you may return an InteractiveQuery object, which should cause 
  the client to respond with more answers, calling this method again.  This
  cycle can continue indefinitely.</p>
  <p>The default implementation always returns AUTH_FAILED.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>responses</code></strong> (list(str)) - list of responses from the client</li>
    </ul></dd>
    <dt>Returns: int or InteractiveQuery</dt>
        <dd>AUTH_FAILED if the authentication fails; AUTH_SUCCESSFUL if it 
          succeeds; AUTH_PARTIALLY_SUCCESSFUL if the interactive auth is 
          successful, but authentication must continue; otherwise an object
          containing queries for the user</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_auth_none"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_auth_none</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">username</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a client may open channels with no (further) 
  authentication.</p>
  <p>Return AUTH_FAILED if the client must authenticate, or AUTH_SUCCESSFUL
  if it's okay for the client to not authenticate.</p>
  <p>The default implementation always returns AUTH_FAILED.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>username</code></strong> (str) - the username of the client.</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>AUTH_FAILED if the authentication fails; AUTH_SUCCESSFUL if it 
          succeeds.</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_auth_password"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_auth_password</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">username</span>,
        <span class="sig-arg">password</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a given username and password supplied by the client is 
  acceptable for use in authentication.</p>
  <p>Return AUTH_FAILED if the password is not accepted, AUTH_SUCCESSFUL if
  the password is accepted and completes the authentication, or 
  AUTH_PARTIALLY_SUCCESSFUL if your authentication is stateful, and this 
  key is accepted for authentication, but more authentication is required.
  (In this latter case, <a 
  href="paramiko.ServerInterface-class.html#get_allowed_auths" 
  class="link">get_allowed_auths</a> will be called to report to the client
  what options it has for continuing the authentication.)</p>
  <p>The default implementation always returns AUTH_FAILED.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>username</code></strong> (str) - the username of the authenticating client.</li>
        <li><strong class="pname"><code>password</code></strong> (str) - the password given by the client.</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>AUTH_FAILED if the authentication fails; AUTH_SUCCESSFUL if it 
          succeeds; AUTH_PARTIALLY_SUCCESSFUL if the password auth is 
          successful, but authentication must continue.</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_auth_publickey"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_auth_publickey</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">username</span>,
        <span class="sig-arg">key</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a given key supplied by the client is acceptable for use 
  in authentication.  You should override this method in server mode to 
  check the username and key and decide if you would accept a signature 
  made using this key.</p>
  <p>Return AUTH_FAILED if the key is not accepted, AUTH_SUCCESSFUL if the 
  key is accepted and completes the authentication, or 
  AUTH_PARTIALLY_SUCCESSFUL if your authentication is stateful, and this 
  password is accepted for authentication, but more authentication is 
  required.  (In this latter case, <a 
  href="paramiko.ServerInterface-class.html#get_allowed_auths" 
  class="link">get_allowed_auths</a> will be called to report to the client
  what options it has for continuing the authentication.)</p>
  <p>Note that you don't have to actually verify any key signtature here. 
  If you're willing to accept the key, paramiko will do the work of 
  verifying the client's signature.</p>
  <p>The default implementation always returns AUTH_FAILED.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>username</code></strong> (str) - the username of the authenticating client</li>
        <li><strong class="pname"><code>key</code></strong> (<a href="paramiko.PKey-class.html" class="link">PKey</a>) - the key object provided by the client</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>AUTH_FAILED if the client can't authenticate with this key; 
          AUTH_SUCCESSFUL if it can; AUTH_PARTIALLY_SUCCESSFUL if it can 
          authenticate with this key but must continue with authentication</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_channel_direct_tcpip_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_direct_tcpip_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">chanid</span>,
        <span class="sig-arg">origin</span>,
        <span class="sig-arg">destination</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a local port forwarding channel will be granted, and 
  return <code>OPEN_SUCCEEDED</code> or an error code.  This method is 
  called in server mode when the client requests a channel, after 
  authentication is complete.</p>
  <p>The <code>chanid</code> parameter is a small number that uniquely 
  identifies the channel within a <a href="paramiko.Transport-class.html" 
  class="link">Transport</a>.  A <a href="paramiko.Channel-class.html" 
  class="link">Channel</a> object is not created unless this method returns
  <code>OPEN_SUCCEEDED</code> -- once a <a 
  href="paramiko.Channel-class.html" class="link">Channel</a> object is 
  created, you can call <a href="paramiko.Channel-class.html#get_id" 
  class="link">Channel.get_id</a> to retrieve the channel ID.</p>
  <p>The origin and destination parameters are (ip_address, port) tuples 
  that correspond to both ends of the TCP connection in the forwarding 
  tunnel.</p>
  <p>The return value should either be <code>OPEN_SUCCEEDED</code> (or 
  <code>0</code>) to allow the channel request, or one of the following 
  error codes to reject it:</p>
  <ul>
    <li>
      <code>OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</code>
    </li>
    <li>
      <code>OPEN_FAILED_CONNECT_FAILED</code>
    </li>
    <li>
      <code>OPEN_FAILED_UNKNOWN_CHANNEL_TYPE</code>
    </li>
    <li>
      <code>OPEN_FAILED_RESOURCE_SHORTAGE</code>
    </li>
  </ul>
  <p>The default implementation always returns 
  <code>OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>chanid</code></strong> (int) - ID of the channel</li>
        <li><strong class="pname"><code>origin</code></strong> (tuple) - 2-tuple containing the IP address and port of the originator 
          (client side)</li>
        <li><strong class="pname"><code>destination</code></strong> (tuple) - 2-tuple containing the IP address and port of the destination 
          (server side)</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>a success or failure code (listed above)</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_channel_exec_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_exec_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">channel</span>,
        <span class="sig-arg">command</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a shell command will be executed for the client.  If this
  method returns <code>True</code>, the channel should be connected to the 
  stdin, stdout, and stderr of the shell command.</p>
  <p>The default implementation always returns <code>False</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>channel</code></strong> (<a href="paramiko.Channel-class.html" class="link">Channel</a>) - the <a href="paramiko.Channel-class.html" 
          class="link">Channel</a> the request arrived on.</li>
        <li><strong class="pname"><code>command</code></strong> (str) - the command to execute.</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd><code>True</code> if this channel is now hooked up to the stdin, 
          stdout, and stderr of the executing command; <code>False</code> 
          if the command will not be executed.</dd>
  </dl>
<div class="fields">      <p><strong>Since:</strong>
        1.1
      </p>
</div></td></tr></table>
</div>
<a name="check_channel_pty_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_pty_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">channel</span>,
        <span class="sig-arg">term</span>,
        <span class="sig-arg">width</span>,
        <span class="sig-arg">height</span>,
        <span class="sig-arg">pixelwidth</span>,
        <span class="sig-arg">pixelheight</span>,
        <span class="sig-arg">modes</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a pseudo-terminal of the given dimensions (usually 
  requested for shell access) can be provided on the given channel.</p>
  <p>The default implementation always returns <code>False</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>channel</code></strong> (<a href="paramiko.Channel-class.html" class="link">Channel</a>) - the <a href="paramiko.Channel-class.html" 
          class="link">Channel</a> the pty request arrived on.</li>
        <li><strong class="pname"><code>term</code></strong> (str) - type of terminal requested (for example, 
          <code>&quot;vt100&quot;</code>).</li>
        <li><strong class="pname"><code>width</code></strong> (int) - width of screen in characters.</li>
        <li><strong class="pname"><code>height</code></strong> (int) - height of screen in characters.</li>
        <li><strong class="pname"><code>pixelwidth</code></strong> (int) - width of screen in pixels, if known (may be <code>0</code> if 
          unknown).</li>
        <li><strong class="pname"><code>pixelheight</code></strong> (int) - height of screen in pixels, if known (may be <code>0</code> if 
          unknown).</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd><code>True</code> if the psuedo-terminal has been allocated; 
          <code>False</code> otherwise.</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_channel_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">kind</span>,
        <span class="sig-arg">chanid</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a channel request of a given type will be granted, and 
  return <code>OPEN_SUCCEEDED</code> or an error code.  This method is 
  called in server mode when the client requests a channel, after 
  authentication is complete.</p>
  <p>If you allow channel requests (and an ssh server that didn't would be 
  useless), you should also override some of the channel request methods 
  below, which are used to determine which services will be allowed on a 
  given channel:</p>
  <ul>
    <li>
      <a 
      href="paramiko.ServerInterface-class.html#check_channel_pty_request" 
      class="link">check_channel_pty_request</a>
    </li>
    <li>
      <a 
      href="paramiko.ServerInterface-class.html#check_channel_shell_request"
      class="link">check_channel_shell_request</a>
    </li>
    <li>
      <a 
      href="paramiko.ServerInterface-class.html#check_channel_subsystem_request"
      class="link">check_channel_subsystem_request</a>
    </li>
    <li>
      <a 
      href="paramiko.ServerInterface-class.html#check_channel_window_change_request"
      class="link">check_channel_window_change_request</a>
    </li>
    <li>
      <a 
      href="paramiko.ServerInterface-class.html#check_channel_x11_request" 
      class="link">check_channel_x11_request</a>
    </li>
  </ul>
  <p>The <code>chanid</code> parameter is a small number that uniquely 
  identifies the channel within a <a href="paramiko.Transport-class.html" 
  class="link">Transport</a>.  A <a href="paramiko.Channel-class.html" 
  class="link">Channel</a> object is not created unless this method returns
  <code>OPEN_SUCCEEDED</code> -- once a <a 
  href="paramiko.Channel-class.html" class="link">Channel</a> object is 
  created, you can call <a href="paramiko.Channel-class.html#get_id" 
  class="link">Channel.get_id</a> to retrieve the channel ID.</p>
  <p>The return value should either be <code>OPEN_SUCCEEDED</code> (or 
  <code>0</code>) to allow the channel request, or one of the following 
  error codes to reject it:</p>
  <ul>
    <li>
      <code>OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</code>
    </li>
    <li>
      <code>OPEN_FAILED_CONNECT_FAILED</code>
    </li>
    <li>
      <code>OPEN_FAILED_UNKNOWN_CHANNEL_TYPE</code>
    </li>
    <li>
      <code>OPEN_FAILED_RESOURCE_SHORTAGE</code>
    </li>
  </ul>
  <p>The default implementation always returns 
  <code>OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>kind</code></strong> (str) - the kind of channel the client would like to open (usually 
          <code>&quot;session&quot;</code>).</li>
        <li><strong class="pname"><code>chanid</code></strong> (int) - ID of the channel</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>a success or failure code (listed above)</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_channel_shell_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_shell_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">channel</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a shell will be provided to the client on the given 
  channel.  If this method returns <code>True</code>, the channel should be
  connected to the stdin/stdout of a shell (or something that acts like a 
  shell).</p>
  <p>The default implementation always returns <code>False</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>channel</code></strong> (<a href="paramiko.Channel-class.html" class="link">Channel</a>) - the <a href="paramiko.Channel-class.html" 
          class="link">Channel</a> the request arrived on.</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd><code>True</code> if this channel is now hooked up to a shell; 
          <code>False</code> if a shell can't or won't be provided.</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_channel_subsystem_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_subsystem_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">channel</span>,
        <span class="sig-arg">name</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if a requested subsystem will be provided to the client on 
  the given channel.  If this method returns <code>True</code>, all future 
  I/O through this channel will be assumed to be connected to the requested
  subsystem.  An example of a subsystem is <code>sftp</code>.</p>
  <p>The default implementation checks for a subsystem handler assigned via
  <a href="paramiko.Transport-class.html#set_subsystem_handler" 
  class="link">Transport.set_subsystem_handler</a>. If one has been set, 
  the handler is invoked and this method returns <code>True</code>.  
  Otherwise it returns <code>False</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>channel</code></strong> (<a href="paramiko.Channel-class.html" class="link">Channel</a>) - the <a href="paramiko.Channel-class.html" 
          class="link">Channel</a> the pty request arrived on.</li>
        <li><strong class="pname"><code>name</code></strong> (str) - name of the requested subsystem.</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd><code>True</code> if this channel is now hooked up to the 
          requested subsystem; <code>False</code> if that subsystem can't 
          or won't be provided.</dd>
  </dl>
<div class="fields">      <p><strong>Note:</strong>
        Because the default implementation uses the <a 
        href="paramiko.Transport-class.html" class="link">Transport</a> to 
        identify valid subsystems, you probably won't need to override this
        method.
      </p>
</div></td></tr></table>
</div>
<a name="check_channel_window_change_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_window_change_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">channel</span>,
        <span class="sig-arg">width</span>,
        <span class="sig-arg">height</span>,
        <span class="sig-arg">pixelwidth</span>,
        <span class="sig-arg">pixelheight</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if the pseudo-terminal on the given channel can be resized. 
  This only makes sense if a pty was previously allocated on it.</p>
  <p>The default implementation always returns <code>False</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>channel</code></strong> (<a href="paramiko.Channel-class.html" class="link">Channel</a>) - the <a href="paramiko.Channel-class.html" 
          class="link">Channel</a> the pty request arrived on.</li>
        <li><strong class="pname"><code>width</code></strong> (int) - width of screen in characters.</li>
        <li><strong class="pname"><code>height</code></strong> (int) - height of screen in characters.</li>
        <li><strong class="pname"><code>pixelwidth</code></strong> (int) - width of screen in pixels, if known (may be <code>0</code> if 
          unknown).</li>
        <li><strong class="pname"><code>pixelheight</code></strong> (int) - height of screen in pixels, if known (may be <code>0</code> if 
          unknown).</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd><code>True</code> if the terminal was resized; <code>False</code>
          if not.</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_channel_x11_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_channel_x11_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">channel</span>,
        <span class="sig-arg">single_connection</span>,
        <span class="sig-arg">auth_protocol</span>,
        <span class="sig-arg">auth_cookie</span>,
        <span class="sig-arg">screen_number</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Determine if the client will be provided with an X11 session.  If this
  method returns <code>True</code>, X11 applications should be routed 
  through new SSH channels, using <a 
  href="paramiko.Transport-class.html#open_x11_channel" 
  class="link">Transport.open_x11_channel</a>.</p>
  <p>The default implementation always returns <code>False</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>channel</code></strong> (<a href="paramiko.Channel-class.html" class="link">Channel</a>) - the <a href="paramiko.Channel-class.html" 
          class="link">Channel</a> the X11 request arrived on</li>
        <li><strong class="pname"><code>single_connection</code></strong> (bool) - <code>True</code> if only a single X11 channel should be opened</li>
        <li><strong class="pname"><code>auth_protocol</code></strong> (str) - the protocol used for X11 authentication</li>
        <li><strong class="pname"><code>auth_cookie</code></strong> (str) - the cookie used to authenticate to X11</li>
        <li><strong class="pname"><code>screen_number</code></strong> (int) - the number of the X11 screen to connect to</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd><code>True</code> if the X11 session was opened; 
          <code>False</code> if not</dd>
  </dl>
</td></tr></table>
</div>
<a name="check_global_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_global_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">kind</span>,
        <span class="sig-arg">msg</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Handle a global request of the given <code>kind</code>.  This method 
  is called in server mode and client mode, whenever the remote host makes 
  a global request.  If there are any arguments to the request, they will 
  be in <code>msg</code>.</p>
  <p>There aren't any useful global requests defined, aside from port 
  forwarding, so usually this type of request is an extension to the 
  protocol.</p>
  <p>If the request was successful and you would like to return contextual 
  data to the remote host, return a tuple.  Items in the tuple will be sent
  back with the successful result.  (Note that the items in the tuple can 
  only be strings, ints, longs, or bools.)</p>
  <p>The default implementation always returns <code>False</code>, 
  indicating that it does not support any global requests.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>kind</code></strong> (str) - the kind of global request being made.</li>
        <li><strong class="pname"><code>msg</code></strong> (<a href="paramiko.Message-class.html" class="link">Message</a>) - any extra arguments to the request.</li>
    </ul></dd>
    <dt>Returns: bool</dt>
        <dd><code>True</code> or a tuple of data if the request was granted; 
          <code>False</code> otherwise.</dd>
  </dl>
<div class="fields">      <p><strong>Note:</strong>
        Port forwarding requests are handled separately, in <a 
        href="paramiko.ServerInterface-class.html#check_port_forward_request"
        class="link">check_port_forward_request</a>.
      </p>
</div></td></tr></table>
</div>
<a name="check_port_forward_request"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">check_port_forward_request</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">address</span>,
        <span class="sig-arg">port</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Handle a request for port forwarding.  The client is asking that 
  connections to the given address and port be forwarded back across this 
  ssh connection.  An address of <code>&quot;0.0.0.0&quot;</code> indicates
  a global address (any address associated with this server) and a port of 
  <code>0</code> indicates that no specific port is requested (usually the 
  OS will pick a port).</p>
  <p>The default implementation always returns <code>False</code>, 
  rejecting the port forwarding request.  If the request is accepted, you 
  should return the port opened for listening.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>address</code></strong> (str) - the requested address</li>
        <li><strong class="pname"><code>port</code></strong> (int) - the requested port</li>
    </ul></dd>
    <dt>Returns: int</dt>
        <dd>the port number that was opened for listening, or 
          <code>False</code> to reject</dd>
  </dl>
</td></tr></table>
</div>
<a name="get_allowed_auths"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">get_allowed_auths</span>(<span class="sig-arg">self</span>,
        <span class="sig-arg">username</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    ><span class="codelink"><a href="paramiko.server-pysrc.html">source&nbsp;code</a></span>&nbsp;
    </td>
  </tr></table>
  
  <p>Return a list of authentication methods supported by the server. This 
  list is sent to clients attempting to authenticate, to inform them of 
  authentication methods that might be successful.</p>
  <p>The &quot;list&quot; is actually a string of comma-separated names of 
  types of authentication.  Possible values are 
  <code>&quot;password&quot;</code>, <code>&quot;publickey&quot;</code>, 
  and <code>&quot;none&quot;</code>.</p>
  <p>The default implementation always returns 
  <code>&quot;password&quot;</code>.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>username</code></strong> (str) - the username requesting authentication.</li>
    </ul></dd>
    <dt>Returns: str</dt>
        <dd>a comma-separated list of authentication types</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="paramiko-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1 on Mon May 23 13:50:03 2011
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
